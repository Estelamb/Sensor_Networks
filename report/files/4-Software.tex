\section{Software Organization}

\input{files/global.tex}

\clearpage
\input{files/modules.tex}
\clearpage
\input{files/threads.tex}
\clearpage
\input{files/main_thread.tex}
\clearpage
\subsection{Zephyr \acrshort{RTOS}} 

\subsubsection{prj\_nucleo\_wl55jc.conf}

The following configuration file (\texttt{prj\_nucleo\_wl55jc.conf}) specifies the system modules required for enabling the serial console, \gls{GPIO}, \gls{ADC}, and \gls{I2C} interfaces within the Zephyr \gls{RTOS} environment. It also activates several debugging and runtime analysis features, including thread stack initialization, thread information reporting, and the automatic thread analyzer.

\begin{lstlisting}[caption={prj\_nucleo\_wl55jc.conf}]
    CONFIG_STDOUT_CONSOLE=y
    CONFIG_UART_CONSOLE=y
    CONFIG_CONSOLE=y
    CONFIG_PRINTK=y
    CONFIG_CBPRINTF_FP_SUPPORT=y
    CONFIG_POLL=y

    CONFIG_EVENTS=y
    CONFIG_LOG=y

    CONFIG_GPIO=y # Enable GPIO

    CONFIG_ADC=y  # Enable ADC

    CONFIG_I2C=y  # Enable I2C

    CONFIG_SERIAL=y
    CONFIG_UART_INTERRUPT_DRIVEN=y # Enable UART interrupt-driven API

    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y
\end{lstlisting}

\subsubsection{nucleo\_wl55jc.overlay}

Additionally, the DeviceTree overlay file (\texttt{nucleo\_wl55jc.overlay}) extends the hardware description of the Nucleo-WL55JC board by defining a \gls{RGB} \gls{LED} structure implemented through \gls{GPIO}-controlled \gls{LED} nodes. Corresponding aliases are included to simplify application-level access to these components. The overlay also configures the \gls{USART}1 peripheral with its associated pin assignments and baud rate, enabling serial communication capabilities required by the console or other \gls{UART}-based interfaces.

\begin{lstlisting}[caption={nucleo\_wl55jc.overlay}]
    #include <zephyr/dt-bindings/pinctrl/stm32-pinctrl.h>

    / {
        rgb_leds {
            compatible = "gpio-leds";

            rgb_red: rgb_0 {
                gpios = <&gpioa 6 GPIO_ACTIVE_LOW>;
                label = "Red RGB LED";
            };
            rgb_green: rgb_1 {
                gpios = <&gpioa 7 GPIO_ACTIVE_LOW>;
                label = "Green RGB LED";
            };
            rgb_blue: rgb_2 {
                gpios = <&gpioa 9 GPIO_ACTIVE_LOW>;
                label = "Blue RGB LED";
            };
        };

        aliases {
            red = &rgb_red;
            green = &rgb_green;
            blue = &rgb_blue;
            led0 = &blue_led_1; 	// This is LED1 as labeled STM32WL55JC board's 
    		led1 = &green_led_2; 	// This is LED2 as labeled STM32WL55JC board's 
    		led2 = &red_led_3; 	    // This is LED3 as labeled STM32WL55JC board's 
        };


    };

    &usart1 {
        status = "okay";
        current-speed = <9600>;
        pinctrl-0 = <&usart1_tx_pb6 &usart1_rx_pb7>;
        pinctrl-names = "default";
    };

\end{lstlisting}


\subsection{Thread Stack and \acrshort{CPU} Usage Analysis}

Zephyr provides runtime diagnostics that allow monitoring of the stack usage and \gls{CPU} load of each thread in the system. The output shown in the image presents detailed information for all active threads, including their stack consumption, remaining free stack space, and the total number of \gls{CPU} cycles executed since startup.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/stack.png}
    \caption{Thread stack and \gls{CPU} usage}
    \label{fig:stack}
\end{figure}

It is important to understand the purpose of each thread displayed:

\begin{itemize}
    \item \textbf{gps\_thread:} Thread responsible for configuring, reading and parsing \gls{GPS} data.

    \item \textbf{sensors\_thread:} Thread responsible for sensor readings (accelerometer, colour sensor, etc.).

    \item \textbf{thread\_analyzer:} Internal diagnostic thread used to collect and report thread metrics such as stack usage. It runs periodically and only consumes \gls{CPU} during short analysis windows.

    \item \textbf{sysworkq:} The global Zephyr system workqueue. It is used to run small background tasks that do not need their own dedicated thread. Typical examples include executing callbacks.  

    \item \textbf{logging:} Internal Zephyr thread in charge of processing log messages.

    \item \textbf{idle:} Lowest-priority thread that runs whenever no other thread is ready. It accounts for the majority of \gls{CPU} cycles, which is expected and desirable in a low-power sensor system.

    \item \textbf{main:} The initial thread created at system startup.

    \item \textbf{\gls{ISR}0 (\gls{ISR} stack):} Not a regular thread, but the shared stack region used by all interrupt service routines.
\end{itemize}

For each thread, the following metrics are displayed:

\begin{itemize}
    \item \textbf{STACK:} Reports the unused stack space, the amount of stack used, and the total allocated stack size.  
    For example, for \texttt{gps\_thread}:
    \[
    \text{unused } 768 \text{ B},\quad \text{used } 256 \text{ B},\quad \text{total } 1024 \text{ B}
    \]
    This corresponds to a stack usage of 25\%, indicating that the assigned memory is sufficient and no overflow risk is present. 

    As a general guideline, \textbf{stack usage below 60\% is considered safe} in Zephyr, as it leaves enough headroom for context switching, interrupts, and occasional peak loads.

    \item \textbf{\gls{CPU}:} Shows the percentage of \gls{CPU} time consumed by each thread.  
    Most application threads such as \texttt{gps\_thread} or \texttt{sensors\_thread} show 0\% \gls{CPU} usage because they predominantly sleep while waiting for periodic timers or I/O events.

    \item \textbf{Total \gls{CPU} cycles used:} Indicates the cumulative processor cycles consumed by each thread since boot.  
    
    Threads like \texttt{idle} present extremely large values, which is expected since the idle thread runs whenever no other thread is ready to execute. A high idle count is a positive indicator of energy efficiency.
\end{itemize}

This is obtained thanks to the following configuration options enabled in \texttt{prj\_nucleo\_wl55jc.conf}, which allow Zephyr to track stack usage, assign human-readable thread names, and automatically generate periodic thread analysis reports:

\begin{lstlisting}[caption={Thread stack and CPU usage report - prj\_nucleo\_wl55jc.conf}]
    CONFIG_INIT_STACKS=y
    CONFIG_THREAD_STACK_INFO=y
    CONFIG_THREAD_ANALYZER=y
    CONFIG_THREAD_ANALYZER_AUTO=y
    CONFIG_THREAD_NAME=y    
\end{lstlisting}

Overall, the reported values confirm that:

\begin{itemize}
    \item All thread stacks remain within safe usage ranges, with most below the recommended 60\% threshold.
    \item \gls{CPU} usage distribution behaves as expected for a sensor-driven, event-based embedded application.
    \item The idle thread dominates \gls{CPU} cycles, indicating efficient low-power execution and minimal background processing overhead.
\end{itemize}



\subsection{Compilation and Flashing Output Analysis}

During the compilation process, Zephyr generates a memory usage summary that indicates how much Flash and \gls{RAM} the final application occupies. As shown in \autoref{fig:build}, after linking the executable \texttt{zephyr.elf}, the memory report provides the following information:

\begin{itemize}
    \item \textbf{FLASH:} 59.024B used out of 256KB (approximately 22.5\%).
    \item \textbf{\gls{RAM}:} 13.504B used out of 64KB (approximately 20.6\%).
\end{itemize}

This confirms that the firmware comfortably fits within the memory limits of the STM32WL55 microcontroller, leaving sufficient headroom for future improvements or additional functionality.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/build.png}
    \caption{Compilation memory usage report}
    \label{fig:build}
\end{figure}

\subsection{Flashing the Firmware onto the STM32WL55}

The \autoref{fig:flash} corresponds to the flashing process performed using \texttt{STM32CubeProgrammer}, which communicates with the NUCLEO-WL55JC board via the onboard ST-LINK debugger. The tool successfully identifies the target device, displaying key details such as:

\begin{itemize}
    \item \textbf{Device:} STM32WLxx.
    \item \textbf{Flash Size:} 256KB.
    \item \textbf{Core:} \gls{ARM} Cortex-M4.
    \item \textbf{Supply Voltage:} 3.28V.
    \item \textbf{Connection Mode:} Under Reset.
\end{itemize}

After loading the generated \texttt{zephyr.hex} file (57.64KB), the programmer performs the following steps:

\begin{enumerate}
    \item Erases the internal Flash sectors (0 to 28).
    \item Programs the firmware at address \texttt{0x08000000}.
    \item Verifies the integrity of the written data.
    \item Starts the application.
\end{enumerate}

The final message, \textit{``Application is running, Please Hold on...''}, indicates that the microcontroller has successfully been programmed and is now executing the uploaded Zephyr firmware.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/flash.png}
    \caption{Flashing process using STM32CubeProgrammer}
    \label{fig:flash}
\end{figure}

\subsection{Code Documentation}

The project documentation is generated automatically through a continuous integration workflow implemented using a GitHub Action (\autoref{ap:github}). This workflow executes the Doxygen engine, which extracts structured information directly from the annotated comments within the source code. By following Doxygen's documentation conventions, each module, function, and data structure is described where it is implemented, ensuring that the documentation remains consistent with the evolving codebase.

Whenever new commits are pushed to the repository, the GitHub Action is triggered, automatically regenerating the documentation and preventing discrepancies between the implementation and its technical description. As part of the same workflow, the generated documentation is automatically deployed to a GitHub Pages site, making it accessible online without requiring manual intervention.

The documentation can be accessed directly through the following link: \url{https://estelamb.github.io/Embedded_IoT/}.
